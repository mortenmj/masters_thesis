% Chapter Template
\providecommand{\rootfolder}{../..} % Relative path to main.tex
\documentclass[\rootfolder/main.tex]{subfiles}
\begin{document}

\chapter{Implementation of the control system and monitoring application} % Main chapter title

\label{ch:controlsystem} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ch:foo}

\section{Visualizing the behavior tree}

At the outset of this project, the existing solution which used a state machine approach, was evaluated.
SMACH, short for state machine, is a task-level state machine architecture for the Robot Operating System (ROS).
There are some intrinsic issues with large state machines, in particular concerning maintainability and scalability.
As the cyborg state machine grew in size and complexity, these became increasingly apparent.

As outlined in \cref{ch:background}, the events that govern transitions between states in a state machine are tightly coupled.
Because of this, when adding or removing a state, it is necessary to update the transitions between this state and potentially every other state in the state machine.
Furthermore, a state machine with many states can be difficult to grasp as it becomes cluttered, and the many states and transitions require the user to maintain a complex mental model.
Reusability of behaviors can also be difficult, as the states are tightly coupled to their transitions.
Finally, as outlined in the SMACH documentation, SMACH is poorly suited for unstructured tasks.
As one goal of the NTNU Cyborg project is life like behavior, it was found that a decision making approach which is more suited for unstructured behavior was desirable.

After evaluating several options, the behavior tree implementation that was decided on was one called \emph{behavior3}.
behavior3 is implemented as both a Python library, \emph{behavior3py}, as well as a Javascript library, \emph{behavior3js}.
Additionally, the project includes an editor, \emph{behavior3editor}.
The editor provides a graphical interface for creating behavior trees, and allows the user to export these as JSON configuration files.
The configuration files can be parsed and run using behavior3py or behavior3js.
As ROS allows for nodes to be implemented in \CC or Python, this project will use behavior3py.

As described in \cref{ch:background}, a behavior tree is build from standard composite nodes, as well as nodes that implement decorators and actions.
To use behavior3py a ROS node was made, called \emph{cyborg\_bt}, as well as a node for organizing custom decorators and actions called \emph{cyborg\_bt\_nodes}.
cyborg\_bt imports the required decorators and actions needed by the Cyborg control system, from cyborg\_bt\_nodes, and runs the tree produced with behavior3editor.
Much of the functionality required to implement these decorators and actions has been placed in ROS services or topics, in order to make behavior as reusable as possible.

An example of such a node, the action node MoveTo, which moves the Cyborg to a requested location, is included in the appendix (TODO: reference).
The node issues a movement request to the navigation subsystem, and then monitors the progress of the Cyborg as it moves along the path to its target.
If progress stalls for longer than an allowed timeout, the movement request is aborted.
In this case, we monitor the movement along the path to the target and not merely the Euclidean distance to the target.
This is important, as the Cyborg may have to navigate around obstacles along its path which can involve moving further away from the target.

\begin{wrapfigure}{R}{0.4\columnwidth}
    \pimage[0.38]{Figures/patrol}
    \caption{Behavior tree that checks battery state, and charges if necessary, while patrolling}
    \label{fig:patrol-tree}
\end{wrapfigure}

A simple demonstration of a working behavior tree is shown in \cref{fig:patrol-tree}.
This behavior tree causes the cyborg to move in a patrol pattern between several locations while it monitors the state of the Cyborg's battery charge, and recharges as needed.

\section{Monitoring application}

In addition to the control system, a main objective of this thesis is to present the development of an application that allows the user to monitor the status of the Cyborg.
There are several libraries and applications available that allow for visualization of the relevant data, and a choice had to be made regarding which option to choose.

One approach that was evaluated was to create a standalone monitoring application, or even a simple dashboard which could be presented in a web browser.
Among the options that have been investigated are d3, which is a visualization library for Javascript, and Bokeh and Plotly which are visualization libraries for Python.
One of the desired features of the application was that the visualization should be interactive, so that the user could influence the state of the Cyborg.
All three libraries enable rich visualizations in the browser, but Bokeh and Plotly were found to offer a higher degree of interaction.
As interaction is a desired feature in the monitoring application, a Python solution using either Bokeh or Plotly was investigated further.

ROS nodes can be implemented in either \CC or Python, as explained in \cref{ch:background}.
For implementing visualizations as a web service, Python was deemed to be a good choice.
The monitoring application might have been implemented as a ROS node, were it not for the fact that ROS uses Python 2.7. Python 2.7, unfortunately, predates the introduction of asynchronous support in Python.
This presented a challenge.
Two ways to overcome this were identified, which will be explained in the following section.

\section{Rosbridge}

In order to access information from ROS in an outside application, the Robot Web Tools project has developed a protocol called \emph{rosbridge} \cite{Toris}.
The rosbridge protocol exports data from ROS using websocket, which is a two-way TCP protocol, and uses a simple JSON API for communication.
An application, including a web application, can access information from the Cyborg by communicating with ROS using websocket.
This solution makes the interface easily accessible without requiring that the user installs software locally, and it allows for the Cyborg to be monitored from any computer with a web browser.

Existing frontends for rosbridge include \emph{roslibjs}, which is written in Javascript.
As it was found that visualization should be done with Plotly or Bokeh, this would have required porting of roslibjs to Python.

\section{ROS 2.0}

As porting roslibjs to Python would involve a significant amount of work, ROS 2.0 was evaluated as an alternative.
ROS 2.0 is a new project by the creators of ROS, intended to improve on some of the fundamental shortcomings of ROS.
In doing so, it also solves the same problems that rosbridge intends to solve, by making it far easier for outside applications to communicate with an ROS control system.

As outlined in \cref{Gerkey2017}, the development of ROS involved the from-scratch implementation of a publish-subscribe system.
Since the start of the ROS project, many new technologies have become available which provide features beyond the scope of the implementation used in ROS.
Crucially for the purpose of this project ROS 2.0 uses Python 3, which is a requirements for the visualization libraries discussed above.

While the core ROS 2.0 implementation is considered stable and production ready at the time of writing, the Cyborg project depends on ROS nodes that are not yet available for ROS 2.0.
Specifically, the project depends on nodes developed by MobileRobots, the manufacturer of the Pioneer LX, and it is outside the scope of this project to port these to ROS 2.0.
However, ROS 2.0 does include the ability to interoperate with ROS, meaning that it would be possible to leave existing ROS functionality as is, while new functionality could target ROS 2.0.
Unfortunately, many important libraries are not yet ported, including underlying functionality such as nav\_core and move\_base, the navigation and movement subsystems respectively.
Once these subsystems are ported it would be feasible to transition the Cyborg project to ROS 2.0, and certainly to target new functionality at ROS 2.0.

\section{rqt}

After evaluating both rosbridge and ROS 2.0, it was found that these solutions complicated the architecture of the Cyborg control system to an unacceptable degree.
Furthermore, using off-the-shelf solutions wherever possible minimizes the work needed to be performed, and maintained, by the Cyborg project, which allows for efforts to be focused on improving core functionality.

An alternative approach to the solutions described above, and the one decided upon by Martinius Knudsen and the author, was to implement the required functionality as one or more plugins for rqt.
rqt is a Qt-based framework for GUI development for ROS, and comes with a rich set of plugins already available.
rqt provides much of the functionality the Cyborg project requires, such as visualization of time series data, a rich logging interface and command nput.
For these reasons, the choice was made to implement the behavior tree visualization as a plugin for rqt, and use existing rqt plugins for the other visualizations needed by the project.

\begin{figure}[ht]
    \pimage{Figures/rqt-graph}
    \caption{Screenshot of rqt-graph, showing a visualization of the currently running ROS nodes and the communication pathways between them.}
    \label{fig:rqt-graph}
\end{figure}

The behavior tree visualization plugin will be based on the existing rqt graph visualizer, \emph{rqt\_graph}.
This plugin visualizes the nodes that make up the ROS control system, and the communication paths between these nodes, as shown in \cref{fig:rqt-graph}.
The use case for rqt\_graph and the behavior tree plugin are somewhat similar, as they both will generate DOT code that describes the graph, which will then be passed to a Qt library for drawing.
Due to this overlap, the rqt\_graph served as valuable inspiration for the behavior tree plugin.

\subsection{Graphical User Interface}

Implementing the GUI using Qt provides a range of graphical widgets, which can be composed using the Qt Creator software.
The resulting UI text file can then be loaded in Python, which automatically creates objects for each widget specified in the UI file.
Interactive widgets provide signals which are emitted upon actions such as a button click, a value change and so forth.
These signals may be connected to functions implemented by the developer, in order to perform actions when the user interacts with the graphical interface.
Actions may be performed immediately, or they may be deferred in situations where this is required.
For example, long running tasks may cause the interface to become inresponsive if they are executed indiscriminantly, and it may be necessary to defer them for the sake of a better user experience.
Where required, widgets may be subclassed in order to add additional signals, but this has not been necessary for this project.

\begin{figure}[ht]
    \pimage{Figures/qt-creator}
    \caption{Screenshot of Qt Creator}
    \label{fig:qt-creator}
\end{figure}

The behavior tree visualization plugin was named \emph{rqt\_bt}.
The plugin was designed using Qt Creator, as shown in \cref{fig:qt-creator}.
The entire GUI is composed of a widget created by the author, \emph{rqt\_bt\_widget}, which acts as a container for the other components of the GUI.
At the top of the interface, the layout is made up of a \emph{QHBoxLayout} widget, which is a container widget for laying out widgets horizontally.
This widget contains the control buttons for interacting with the application.
Below this the layout contains an \emph{InteractiveGraphicsView} widget.
This is a widget created by the ROS project, which extends the stock \emph{QGraphicsWidget}.
The widget is responsible for drawing the actual graphics view to the screen.
All of the listed widgets subclass \emph{QWidget}, which is the base class for all user interface objects in Qt.

The buttons in the interface allow the user to control the behavior of the plugin in the following ways:

\begin{itemize}
\item The \emph{Highlight Connections} check box check box will cause the interface to highlight the connections from a node to its parent and its children, when the node is hovered over by the mouse.
\item The \emph{Fit} check box will cause the graph to be automatically drawn to fit within the view port, so that the whole graph can be seen at the same time. The graph will resize to fit even if the graph changes.
\item The \emph{Fit in View} push button will cause the graph to be resized to fit in the view port, but only a single time. That is, it will not be automatically updated.
\item The \emph{Draw Depth} spin box allows the user to select how deeply nested behavior trees should be drawn. Trees deeper than the selected level are collapsed to a single node, as shown in \cref{fig:rqt-bt-depth}.
\item The \emph{Save as DOT}, \emph{Save as SVG} and \emph{Save as Image} push buttons allow the user to save the graph in a variety of formats.
\item The \emph{Refresh Graph} push button forces redrawing of the graph.
\item The \emph{Run} push button enables or disables the behavior tree node running in ROS.
\end{itemize}

The run push button deserves some further explanation.
This button allows the user to send an enable or disable service request to the behavior tree node, which pauses execution of the behavior tree.
The plugin monitors the status of the behavior tree, so that the plugin sends the correct service request depending on the current status of the behavior tree.
If the behavior tree node is running, the button displays a pause symbol and the plugin will send a request to halt execution of the behavior tree.
Conversely, if the behavior tree's execution is paused, the button displays a play symbol and the plugin will send a request to resume execution of the behavior tree.

\begin{figure}[ht]
    \pimage{Figures/rqt-bt}
    \caption{Screenshot of rqt\_bt}
    \label{fig:rqt-bt}
\end{figure}

\begin{figure}[ht]
    \pimage{Figures/rqt-bt-depth}
    \caption{Screenshot of rqt\_bt with reduced drawing depth.}
    \label{fig:rqt-bt-depth}
\end{figure}

\subsection{Displaying the tree}

In order to display the behavior tree, as well as which nodes are currently active, two pieces of information are required to be published by the behavior tree node, cyborg\_bt.
Firstly, we require that it publish the structure of the tree, and secondly we require that it publish a list with the IDs of the currently active nodes.
When the cyborg\_bt node is created, the behavior tree is traversed an a NetworkX graph is created that represents the tree.
NetworkX provides a method for converting these graphs to and from JSON data, which allows for transmitting the structure of the tree as a string message on a topic, and recover it upon receipt.
The generated data is made available in two separate topics, as a JSON string and as a list of ID strings, respectively.

\begin{listing}
    \inputminted{Python}{\rootfolder/Chapters/Chapter4/Listings/btdata.py}
    \caption{Implementation of the BTData class for rqt\_bt}
    \label{lst:btdata}
\end{listing}

In order to consume the provided data, the rqt\_bt\_widget creates a \emph{BTData} object, which listens to these two topics, as shown in \cref{lst:btdata}.
The BTData instance is provided to the DOT code generator class, \emph{BTDotcodeGenerator}, shown in \cref{lst:btdotcode}.
The BTData instance will continue to listen to the provided topics, and maintain an updated representation of the behavior tree graph, which can be retrieved using the \emph{get\_graph()} method.
The topics published by cyborg\_bt are latched, meaning that the most recently transmitted message will be retransmitted to any new subscribers.
This means that the BTData instance receives updated information as soon as it is created.
If this is not the case, BTData falls back to providing an empty graph so that consumers of the graph avoid having to add special cases for invalid data.

When rqt\_bt\_widget requires a redraw of the behavior tree graph, either due to periodic redrawing or due to user interaction, the \emph{generate\_dotcode()} method in BTDotcodeGenerator is called.
This method retrieves the current graph and the list of currently active nodes, from its instance of BTData.
The method performs processing of the graph, such as culling nodes that are deeper than the requested drawing depth, and adds highlighting to indicate the currently active nodes.
Finally, DOT code is generated to represent the graph, which is passed back to rqt\_bt\_widget so that it can be drawn by the Qt framework.
If the DOT code has changed since the last time it was drawn, it is passed to an instance of \emph{DotToQtGenerator}.
This class is provided by \emph{qt\_dotgraph}, which is a library created by the ROS project that provides helper functions for drawing DOT graphcs in Qt.

Using the \emph{dotcode\_to\_qt\_items()} method provided by DotToQtGenerator, we create a list of nodes and edges.
These are added to a \emph{QGraphicsScene}, which is finally passed to the QGraphicsView widget described previously, which draws the scene on the user's screen.

\begin{listing}
    \inputminted{Python}{\rootfolder/Chapters/Chapter4/Listings/dotcode.py}
    \caption{Implementation of the BTDotcodeGenerator class for rqt\_bt}
    \label{lst:btdotcode}
\end{listing}

\end{document}
